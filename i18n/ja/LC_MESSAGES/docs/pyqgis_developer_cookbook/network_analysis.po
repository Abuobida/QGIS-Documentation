# 
# Translators:
# Choro <u.ko.kubot@gmail.com>, 2013-2014
# Kohei Tomita <fairtommy@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-05 22:35\n"
"PO-Revision-Date: 2017-08-06 00:18+0000\n"
"Last-Translator: Kohei Tomita <fairtommy@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/qgis/qgis-documentation/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:9
msgid "Network analysis library"
msgstr "ネットワーク分析ライブラリ"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:18
msgid ""
"creates mathematical graph from geographical data (polyline vector layers)"
msgstr "地理データから数学的なグラフ（ポリラインベクタレイヤー）を作成します。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:27
msgid "General information"
msgstr "一般情報"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:31
msgid "create graph from geodata (usually polyline vector layer)"
msgstr "地理データから地理学的なグラフ（たいていはポリラインベクタレイヤー）を作成します。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:32
msgid "run graph analysis"
msgstr "グラフ分析の実行"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:33
msgid "use analysis results (for example, visualize them)"
msgstr "分析結果の利用（例えば、これらの可視化）"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:142
msgid "crs --- coordinate reference system to use. Mandatory argument."
msgstr "crs ---使用する空間参照系。必須の引数です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:143
msgid ""
"otfEnabled --- use \"on the fly\" reprojection or no. By default "
"const:`True` (use OTF)."
msgstr "otfEnabled --- \"その場で\" 再投影を使用するかどうか。デフォルトでは :const:`True` (OTFを使用)."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:145
msgid "topologyTolerance --- topological tolerance. Default value is 0."
msgstr "トポロジ許容値---トポロジ的な許容値です。デフォルト値は0です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:146
msgid "ellipsoidID --- ellipsoid to use. By default \"WGS84\"."
msgstr "楕円体ID --- 使用する楕円体です。デフォルトは \"WGS84\"です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:185
msgid "Graph analysis"
msgstr "グラフ分析"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:212
msgid "source --- input graph"
msgstr "source　--- 入力グラフ "

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:213
msgid ""
"startVertexIdx --- index of the point on the tree (the root of the tree)"
msgstr "startVertexIdx --- ツリー上のポイントのインデックス（ツリーのルート）"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:214
msgid "criterionNum --- number of edge property to use (started from 0)."
msgstr "criterionNum --- 使用するエッジプロパティの数（0から始まる）。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:220
msgid ""
"The :func:`dijkstra` method has the same arguments, but returns two arrays. "
"In the first array element i contains index of the incoming edge or -1 if "
"there are no incoming edges. In the second array element i contains distance"
" from the root of the tree to vertex i or DOUBLE_MAX if vertex i is "
"unreachable from the root."
msgstr ":func:`dijkstra` メソッドは引数は同じですが２つの配列を返します。流入辺が存在しない場合は、最初の配列要素iに流入辺のインデックスまたは-1を含有します。二番目の配列要素iには木の根から頂点iまでの距離が入ります。頂点iが根から到達不能である場合はDOUBLE_MAXが入ります。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:14
msgid ""
"Starting from revision `ee19294562 "
"<https://github.com/qgis/QGIS/commit/ee19294562b00c6ce957945f14c1727210cffdf7>`_"
" (QGIS >= 1.8) the new network analysis library was added to the QGIS core "
"analysis library. The library:"
msgstr "改訂 `ee19294562 <https://github.com/qgis/QGIS/commit/ee19294562b00c6ce957945f14c1727210cffdf7> `_ （QGIS> = 1.8）から始め、新しいネットワーク解析ライブラリがQGISコア解析ライブラリに追加されました。ライブラリ："

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:19
msgid ""
"implements basic methods from graph theory (currently only Dijkstra's "
"algorithm)"
msgstr "グラフ理論からの基本的なメソッドを実装します（現在はダイクストラ法のみ）"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:22
msgid ""
"The network analysis library was created by exporting basic functions from "
"the RoadGraph core plugin and now you can use it's methods in plugins or "
"directly from the Python console."
msgstr "ネットワーク解析ライブラリはRoadGraphコアプラグインからの基本的機能をエクスポートすることによって作成されました。今はそのメソッドをプラグインで、またはPythonのコンソールから直接使用できます。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:29
msgid "Briefly, a typical use case can be described as:"
msgstr "手短に言えば、一般的なユースケースは、次のように記述できます。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:36
msgid "Building a graph"
msgstr "グラフの構築"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:38
msgid ""
"The first thing you need to do --- is to prepare input data, that is to "
"convert a vector layer into a graph. All further actions will use this "
"graph, not the layer."
msgstr "最初にする必要がある事は---入力データを準備することです、つまりベクターレイヤーをグラフに変換することです。これからのすべての操作は、レイヤーではなく、このグラフを使用します。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:42
msgid ""
"As a source we can use any polyline vector layer. Nodes of the polylines "
"become graph vertexes, and segments of the polylines are graph edges. If "
"several nodes have the same coordinates then they are the same graph vertex."
" So two lines that have a common node become connected to each other."
msgstr "ソースとしてどんなポリラインベクトルレイヤーも使用できます。ポリラインの頂点は、グラフの頂点となり、ポリラインのセグメントは、グラフの辺です。いくつかのノードが同じ座標を持っている場合、それらは同じグラフの頂点です。だから共通のノードを持つ2つの線は接続しています。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:47
msgid ""
"Additionally, during graph creation it is possible to \"fix\" (\"tie\") to "
"the input vector layer any number of additional points. For each additional "
"point a match will be found --- the closest graph vertex or closest graph "
"edge. In the latter case the edge will be split and a new vertex added."
msgstr "さらに、グラフの作成時には、入力ベクトルレイヤーに好きな数だけ追加の点を「固定」する（「結びつける」）ことが可能です。追加の点それぞれについて、対応箇所---最も近いグラフの頂点または最も近いグラフの辺、が探し出されます。後者の場合、辺は分割されて新しい頂点が追加されるでしょう。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:52
msgid ""
"Vector layer attributes and length of an edge can be used as the properties "
"of an edge."
msgstr "ベクターレイヤ属性と辺の長さは、辺の性質として使用できます。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:55
msgid ""
"Converting from a vector layer to the graph is done using the `Builder "
"<http://en.wikipedia.org/wiki/Builder_pattern>`_ programming pattern. A "
"graph is constructed using a so-called Director. There is only one Director "
"for now: `QgsLineVectorLayerDirector "
"<http://qgis.org/api/classQgsLineVectorLayerDirector.html>`_. The director "
"sets the basic settings that will be used to construct a graph from a line "
"vector layer, used by the builder to create the graph. Currently, as in the "
"case with the director, only one builder exists: `QgsGraphBuilder "
"<http://qgis.org/api/classQgsGraphBuilder.html>`_, that creates `QgsGraph "
"<http://qgis.org/api/classQgsGraph.html>`_ objects. You may want to "
"implement your own builders that will build a graphs compatible with such "
"libraries as `BGL "
"<http://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ or "
"`NetworkX <http://networkx.lanl.gov/>`_."
msgstr "ベクターレイヤーからグラフへの変換は `ビルダー<http://en.wikipedia.org/wiki/Builder_pattern>`_ プログラミングパターンを使用して行われます。グラフは、いわゆるディレクターを用いて構成されています。今のところ唯一のディレクターがあります： `QgsLineVectorLayerDirector<http://qgis.org/api/classQgsLineVectorLayerDirector.html>`_ 。ディレクターは、グラフを作成するためにビルダーによって使用される線ベクトルレイヤーからグラフを構築するために使用される基本的な設定を設定します。現在、ディレクターとの場合のように、ビルダーは一つだけ存在します： `QgsGraphBuilder<http://qgis.org/api/classQgsGraphBuilder.html>`_ 、それは`QgsGraph <http://qgis.org/api/classQgsGraph.html>`_ オブジェクトを作成します。自作のビルダーは`BGL<http://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ か、`NetworkX <http://networkx.lanl.gov/>`_ などのライブラリと互換性のあるグラフを構築するように実装できます。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:66
msgid ""
"To calculate edge properties the programming pattern `strategy "
"<http://en.wikipedia.org/wiki/Strategy_pattern>`_ is used. For now only "
"`QgsDistanceArcProperter "
"<http://qgis.org/api/classQgsDistanceArcProperter.html>`_ strategy is "
"available, that takes into account the length of the route. You can "
"implement your own strategy that will use all necessary parameters. For "
"example, RoadGraph plugin uses a strategy that computes travel time using "
"edge length and speed value from attributes."
msgstr "辺性質を計算するにはプログラミングパターン `戦略<http://en.wikipedia.org/wiki/Strategy_pattern>`_ が使用されます。今のところ利用できるのは、経路の長さを考慮に入れる `QgsDistanceArcProperter<http://qgis.org/api/classQgsDistanceArcProperter.html>`_ 戦略だけです。すべての必要なパラメータを使用する独自の戦略を実装できます。例えば、RoadGraphプラグインは、属性から辺長と速度値を使用して旅行時間を計算する戦略を使用します。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:73
msgid "It's time to dive into the process."
msgstr "プロセスに飛び込む時間です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:75
msgid ""
"First of all, to use this library we should import the networkanalysis "
"module"
msgstr "まず第一に、このライブラリを使用するために、networkanalysisモジュールをインポートする必要があります"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:81
msgid "Then some examples for creating a director"
msgstr "ディレクターを作成するためのその後いくつかの例"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:96
msgid ""
"To construct a director  we should pass a vector layer, that will be used as"
" the source for the graph structure and information about allowed movement "
"on each road segment (one-way or bidirectional movement, direct or reverse "
"direction). The call looks like this"
msgstr "ディレクタを構築するために、ベクターレイヤーを渡さなければなりません。これはグラフ構造および各道路セグメント上で許される移動（一方向または双方向の動き、順または逆の方向）についての情報のソースとして使用されるでしょう。呼び出しは次のようになります"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:109
msgid "And here is full list of what these parameters mean:"
msgstr "そして、ここでこれらのパラメータは何を意味するかの完全なリストは以下のとおりです。 "

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:111
msgid "``vl`` --- vector layer used to build the graph"
msgstr "``vl`` ---グラフを構築するために使用される ベクターレイヤー"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:112
msgid ""
"``directionFieldId`` --- index of the attribute table field, where "
"information about roads direction is stored. If ``-1``, then don't use this "
"info at all. An integer."
msgstr "``directionFieldId`` ---道路の方向に関する情報が格納されている属性テーブルのフィールドのインデックス。`` -1``、その後、まったくこの情報を使用しない場合。整数。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:115
msgid ""
"``directDirectionValue`` --- field value for roads with direct direction "
"(moving from first line point to last one). A string."
msgstr "``directDirectionValue`` ---順方向（線の最初の点から最後の点へ移動）の道に対するフィールド値。文字列。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:117
msgid ""
"``reverseDirectionValue`` --- field value for roads with reverse direction "
"(moving from last line point to first one). A string."
msgstr "``reverseDirectionValue`` ---逆方向（線の最後の点から最初の点へ移動）の道に対するフィールド値。文字列。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:119
msgid ""
"``bothDirectionValue`` --- field value for bidirectional roads (for such "
"roads we can move from first point to last and from last to first). A "
"string."
msgstr "``bothDirectionValue`` ---双方向道路に対するフィールド値（例えば最初の点から最後まで、また最後から最初まで移動できる道に対する）。文字列。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:121
msgid ""
"``defaultDirection`` --- default road direction. This value will be used for"
" those roads where field ``directionFieldId`` is not set or has some value "
"different from any of the three values specified above. An integer. ``1`` "
"indicates direct direction, ``2`` indicates reverse direction, and ``3`` "
"indicates both directions."
msgstr "``defaultDirection`` ---デフォルトの道路の方向。この値は、フィールド ``directionFieldId```が設定されていない、または上で指定された3つの値のいずれとも異なる値を有する道路に使用されるであろう。整数。``1`` は順方向、 ``2`` は逆方向、 ``3`` は両方向を示します。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:127
msgid ""
"It is necessary then to create a strategy for calculating edge properties"
msgstr "それから、辺性質を計算するための戦略を作成することが必要です"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:133
msgid "And tell the director about this strategy"
msgstr "そして、ディレクターにこの戦略について教えます"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:139
msgid ""
"Now we can use the builder, which will create the graph. The QgsGraphBuilder"
" class constructor takes several arguments:"
msgstr "これで、グラフを作成するビルダーを使用できます。QgsGraphBuilderクラスのコンストラクタには、いくつかの引数を取ります。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:153
msgid ""
"Also we can define several points, which will be used in the analysis. For "
"example"
msgstr "分析に使用されるいくつかのポイントを、定義することもできます。例えば"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:161
msgid ""
"Now all is in place so we can build the graph and \"tie\" these points to it"
msgstr "これですべてが整いましたので、グラフを構築し、それにこれらの点を「結びつける」ことができます。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:167
msgid ""
"Building the graph can take some time (which depends on the number of "
"features in a layer and layer size). ``tiedPoints`` is a list with "
"coordinates of \"tied\" points. When the build operation is finished we can "
"get the graph and use it for the analysis"
msgstr "グラフを構築するには（レイヤー中の図形数とレイヤーのサイズのに応じて）いくらか時間がかかることがあります。 ``tiedPoints`` は「結ばれた」点の座標とのリストです。ビルド操作が完了すると、グラフは取得して分析のために使用できます"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:176
msgid "With the next code we can get the vertex indexes of our points"
msgstr "次のコードで、点の頂点インデックスを取得できます"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:187
msgid ""
"Networks analysis is used to find answers to two questions: which vertexes "
"are connected and how to find a shortest path. To solve these problems the "
"network analysis library provides Dijkstra's algorithm."
msgstr "ネットワーク分析はこの二つの質問に対する答えを見つけるために使用されます：どの頂点が接続されているか、どのように最短経路を検索するか。これらの問題を解決するため、ネットワーク解析ライブラリではダイクストラのアルゴリズムを提供しています。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:191
msgid ""
"Dijkstra's algorithm finds the shortest route from one of the vertexes of "
"the graph to all the others and the values of the optimization parameters. "
"The results can be represented as a shortest path tree."
msgstr "ダイクストラ法は、グラフの１つの頂点から他のすべての頂点への最短ルートおよび最適化パラメータの値を見つけます。結果は、最短経路木として表現できます。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:195
msgid ""
"The shortest path tree is a directed weighted graph (or more precisely --- "
"tree) with the following properties:"
msgstr "最短経路木は、次の性質を有する有向重み付きグラフ（より正確には、木）です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:198
msgid "only one vertex has no incoming edges — the root of the tree"
msgstr "流入する辺がない頂点が1つだけあります - 木の根"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:199
msgid "all other vertexes have only one incoming edge"
msgstr "他のすべての頂点には流入する辺が１つだけあります"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:200
msgid ""
"if vertex B is reachable from vertex A, then the path from A to B is the "
"single available path and it is optimal (shortest) on this graph"
msgstr "頂点Bが頂点Aから到達可能である場合、このグラフ上のAからBへの経路は、単一の利用可能な経路であり、それは最適（最短）です"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:203
msgid ""
"To get the shortest path tree use the methods :func:`shortestTree` and "
":func:`dijkstra` of `QgsGraphAnalyzer "
"<http://qgis.org/api/classQgsGraphAnalyzer.html>`_ class. It is recommended "
"to use method :func:`dijkstra` because it works faster and uses memory more "
"efficiently."
msgstr "最短経路木を得るには、 `QgsGraphAnalyzer<http://qgis.org/api/classQgsGraphAnalyzer.html>`_ クラスの :func:`shortestTree` と :func:`dijkstra` メソッドを使用してください。より速く動作し、より多くのメモリを効率的に使用するため、 メソッド :func:`dijkstra` を使用することをお勧めします。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:208
msgid ""
"The :func:`shortestTree` method is useful when you want to walk around the "
"shortest path tree. It always creates a new graph object (QgsGraph) and "
"accepts three variables:"
msgstr "最短経路木の周りを歩くしたい場合 :func:`shortestTree` メソッドが便利です。それは、常に新しいグラフオブジェクト（QgsGraph）を作成し、三つの変数を受けとります。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:230
msgid ""
"Here is some very simple code to display the shortest path tree using the "
"graph created with the :func:`shortestTree` method (select linestring layer "
"in TOC and replace coordinates with your own). **Warning**: use this code "
"only as an example, it creates a lots of `QgsRubberBand "
"<http://qgis.org/api/classQgsRubberBand.html>`_ objects and may be slow on "
"large data-sets."
msgstr ":func:`shortestTree` メソッド（TOCでラインストリングのレイヤーを選択し、自分で座標を置き換える）ここで作成したグラフを使用して最短パスツリーを表示するには、いくつかの非常に単純なコードです。 **警告** ：このコードはほんの一例として使用してください、それは多くの `QgsRubberBand<http://qgis.org/api/classQgsRubberBand.html>`_ オブジェクトを作成し、大規模なデータセットでは低速になることがあります。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:270
msgid "Same thing but using :func:`dijkstra` method"
msgstr "同じですが :func:`dijkstra` メソッドを使用して"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:307
msgid "Finding shortest paths"
msgstr "最短経路を見つける"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:309
msgid ""
"To find the optimal path between two points the following approach is used. "
"Both points (start A and end B) are \"tied\" to the graph when it is built. "
"Then using the methods :func:`shortestTree` or :func:`dijkstra` we build the"
" shortest path tree with root in the start point A. In the same tree we also"
" find the end point B and start to walk through the tree from point B to "
"point A. The whole algorithm can be written as"
msgstr "2点間の最適経路を見つけるために下のアプローチが使用されます。両方の点（始点Aおよび終点B）は構築されたときにグラフに「結ばれます」。それから、メソッド :func:`shortestTree` または :func:`dijkstra` を使用して、開始点Aに根を持つ最短経路木を構築します。また、同じ木の中に終点Bを見つけ、木を点Aから点Bまで歩き始めます。全体のアルゴリズムは次のように書けます"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:326
msgid ""
"At this point we have the path, in the form of the inverted list of vertexes"
" (vertexes are listed in reversed order from end point to start point) that "
"will be visited during traveling by this path."
msgstr "この時点において、この経路で走行中に訪問される頂点の反転リストの形（頂点は逆順で終点から始点へと列挙されている）で、経路が得られます。　"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:330
msgid ""
"Here is the sample code for QGIS Python Console (you will need to select "
"linestring layer in TOC and replace coordinates in the code with yours) that"
" uses method :func:`shortestTree`"
msgstr "これはメソッド :func:`shortestTree` を使用するQGIS Pythonコンソールのためのサンプルコードです（TOC中のラインストリングレイヤーを選択して、コードの座標を自分のものに置き換える必要があります）"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:384
msgid "And here is the same sample but using :func:`dijkstra` method"
msgstr "そしてこれは同じサンプルですが :func:`dijkstra` メソッドを使用しています"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:434
msgid "Areas of availability"
msgstr "利用可能領域"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:436
msgid ""
"The area of availability for vertex A is the subset of graph vertexes that "
"are accessible from vertex A and the cost of the paths from A to these "
"vertexes are not greater that some value."
msgstr "頂点Aに対する利用可能領域とは、頂点Aから到達可能であり、Aからこれらの頂点までの経路のコストがある値以下になるような、グラフの頂点の部分集合です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:440
msgid ""
"More clearly this can be shown with the following example: \"There is a fire"
" station. Which parts of city can a fire truck reach in 5 minutes? 10 "
"minutes? 15 minutes?\". Answers to these questions are fire station's areas "
"of availability."
msgstr "より明確に、これは次の例で示すことができる。「消防署があります。市内の部分へ、消防車が5分で、10分で、15分で到達できますか？」。これらの質問への回答は、消防署の利用可能領域です。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:445
msgid ""
"To find the areas of availability we can use method :func:`dijkstra` of the "
":class:`QgsGraphAnalyzer` class. It is enough to compare the elements of the"
" cost array with a predefined value. If cost[i] is less than or equal to a "
"predefined value, then vertex i is inside the area of availability, "
"otherwise it is outside."
msgstr "利用可能領域を見つけるためには、 :class:`QgsGraphAnalyzer` クラスのメソッド :func:`dijkstra` を使用できます。事前に定義された値とコスト配列の要素を比較すれば十分です。コスト[i]が所定値以下の場合は、頂点iは利用可能領域内に、そうでない場合は利用可能領域外にあります。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:451
msgid ""
"A more difficult problem is to get the borders of the area of availability. "
"The bottom border is the set of vertexes that are still accessible, and the "
"top border is the set of vertexes that are not accessible. In fact this is "
"simple: it is the availability border based on the edges of the shortest "
"path tree for which the source vertex of the edge is accessible and the "
"target vertex of the edge is not."
msgstr "より難しい問題は、利用可能領域の境界を取得することです。下限はまだ到達できる頂点の集合であり、上限は到達できない頂点の集合です。実際にはこれは簡単です：それは、最短経路木の辺に基づいて利用可能境界された辺の元頂点はアクセス可能であり、辺の先頂点ではありません。"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:458
msgid "Here is an example"
msgstr "例があります"

#~ msgid ""
#~ "Starting from revision `ee19294562 <https://github.com/qgis/Quantum-"
#~ "GIS/commit/ee19294562b00c6ce957945f14c1727210cffdf7>`_ (QGIS >= 1.8) the new"
#~ " network analysis library was added to the QGIS core analysis library. The "
#~ "library:"
#~ msgstr ""

#~ msgid ""
#~ "implements basics method of the graph theory (currently only Dijkstra's "
#~ "algorithm)"
#~ msgstr ""

#~ msgid ""
#~ "Network analysis library was created by exporting basics functions from "
#~ "RoadGraph core plugin and now you can use it's methods in plugins or "
#~ "directly from Python console."
#~ msgstr ""

#~ msgid "Briefly typical use case can be described as:"
#~ msgstr ""

#~ msgid "Building graph"
#~ msgstr ""

#~ msgid ""
#~ "The first thing you need to do --- is to prepare input data, that is to "
#~ "convert vector layer into graph. All further actions will use this graph, "
#~ "not the layer."
#~ msgstr ""

#~ msgid ""
#~ "As a source we can use any polyline vector layer. Nodes of the polylines "
#~ "become graph vertices, and segments of the polylines are graph edges. If "
#~ "several nodes have the same coordinates then they are the same graph vertex."
#~ " So two lines that have a common node become connected to each other."
#~ msgstr ""

#~ msgid ""
#~ "Additionally, during graph creation it is possible to \"fix\" (\"tie\") to "
#~ "the input vector layer any number of additional points. For each additional "
#~ "point a match will be found --- closest graph vertex or closest graph edge. "
#~ "In the latter case the edge will be splitted and new vertex added."
#~ msgstr ""

#~ msgid ""
#~ "As the properties of the edge a vector layer attributes can be used and "
#~ "length of the edge."
#~ msgstr ""

#~ msgid ""
#~ "Converter from vector layer to graph is developed using `Builder "
#~ "<http://en.wikipedia.org/wiki/Builder_pattern>`_ programming pattern. For "
#~ "graph construction response so-called Director. There is only one Director "
#~ "for now: `QgsLineVectorLayerDirector "
#~ "<http://qgis.org/api/api/classQgsLineVectorLayerDirector.html>`_. The "
#~ "director sets the basic settings that will be used to construct a graph from"
#~ " a line vector layer, used by the builder to create graph. Currently, as in "
#~ "the case with the director, only one builder exists: `QgsGraphBuilder "
#~ "<http://qgis.org/api/api/classQgsGraphBuilder.html>`_, that creates "
#~ "`QgsGraph <http://qgis.org/api/api/classQgsGraph.html>`_ objects. You may "
#~ "want to implement your own builders that will build a graphs compatible with"
#~ " such libraries as `BGL "
#~ "<http://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ or "
#~ "`NetworkX <http://networkx.lanl.gov/>`_."
#~ msgstr ""

#~ msgid ""
#~ "To calculate edge properties programming pattern `strategy "
#~ "<http://en.wikipedia.org/wiki/Strategy_pattern>`_ is used. For now only "
#~ "`QgsDistanceArcProperter "
#~ "<http://qgis.org/api/api/classQgsDistanceArcProperter.html>`_ strategy is "
#~ "available, that takes into account the length of the route. You can "
#~ "implement your own strategy that will use all necessary parameters. For "
#~ "example, RoadGraph plugin uses strategy that compute travel time using edge "
#~ "length and speed value from attributes."
#~ msgstr ""

#~ msgid "It's time to dive in the process."
#~ msgstr ""

#~ msgid ""
#~ "First of all, to use this library we should import networkanalysis module::"
#~ msgstr ""

#~ msgid "Than create director::"
#~ msgstr ""

#~ msgid ""
#~ "To construct a director  we should pass vector layer, that will be used as "
#~ "source for graph and information about allowed movement on each road segment"
#~ " (unilateral or bilateral movement, direct or reverse direction). Here is "
#~ "full list of this parameters:"
#~ msgstr ""

#~ msgid "vl --- vector layer used to build graph"
#~ msgstr ""

#~ msgid ""
#~ "directionFieldId --- index of the attribute table field, where information "
#~ "about roads directions is stored. If -1, then don't use this info at all"
#~ msgstr ""

#~ msgid ""
#~ "directDirectionValue --- field value for roads with direct direction (moving"
#~ " from first line point to last one)"
#~ msgstr ""

#~ msgid ""
#~ "reverseDirectionValue --- field value for roads with reverse direction "
#~ "(moving from last line point to first one)"
#~ msgstr ""

#~ msgid ""
#~ "bothDirectionValue --- field value for bilateral roads (for such roads we "
#~ "can move from first point to last and from last to first)"
#~ msgstr ""

#~ msgid ""
#~ "defaultDirection --- default road direction. This value will be used for "
#~ "those roads where field directionFieldId is not set or have some value "
#~ "different from above."
#~ msgstr ""

#~ msgid ""
#~ "It is necessary then to create strategy for calculating edge properties::"
#~ msgstr ""

#~ msgid "And tell the director about this strategy::"
#~ msgstr ""

#~ msgid ""
#~ "Now we can create builder, which will create graph. QgsGraphBuilder "
#~ "constructor takes several arguments:"
#~ msgstr ""

#~ msgid ""
#~ "Also  we can set several points, which will be used in analysis. For "
#~ "example::"
#~ msgstr ""

#~ msgid "Now all is in place so we can build graph and \"tie\" points to it::"
#~ msgstr ""

#~ msgid ""
#~ "Building graph can take some time (depends on number of features in a layer "
#~ "and layer size). tiedPoints is a list with coordinates of \"tied\" points. "
#~ "When build operation is finished we can get graph and use it for the "
#~ "analysis::"
#~ msgstr ""

#~ msgid "With the next code we can get indexes of our points::"
#~ msgstr ""

#~ msgid ""
#~ "Networks analysis is used to find answers on two questions: which vertices "
#~ "are connected and how to find a shortest path. To solve this problems "
#~ "network analysis library provides Dijkstra's algorithm."
#~ msgstr ""

#~ msgid ""
#~ "Dijkstra's algorithm finds the best route from one of the vertices of the "
#~ "graph to all the others and the values of the optimization parameters. The "
#~ "results can be represented as shortest path tree."
#~ msgstr ""

#~ msgid ""
#~ "The shortest path tree is as oriented weighted graph (or more precisely --- "
#~ "tree) with the following properties:"
#~ msgstr ""

#~ msgid "only one vertex have no incoming edges — the root of the tree"
#~ msgstr ""

#~ msgid "all other vertices have only one incoming edge"
#~ msgstr ""

#~ msgid ""
#~ "if vertex B is reachable from vertex A, then path from A to B is single "
#~ "available path and it is optimal (shortest) on this graph"
#~ msgstr ""

#~ msgid ""
#~ "To get shortest path tree use methods Use methods :func:`shortestTree` and "
#~ ":func:`dijkstra` of `QgsGraphAnalyzer "
#~ "<http://qgis.org/api/api/classQgsGraphAnalyzer.html>`_ class. It is "
#~ "recommended to use method :func:`dijkstra` because it works faster and uses "
#~ "memory more efficiently."
#~ msgstr ""

#~ msgid ""
#~ "The :func:`shortestTree` method is useful when you want to walk around the "
#~ "shortest path tree. It always creates new graph object (QgsGraph) and "
#~ "accepts three variables:"
#~ msgstr ""

#~ msgid ""
#~ "Here is very simple code to display shortest path tree using graph created "
#~ "with :func:`shortestTree` method (select linestring layer in TOC and replace"
#~ " coordinates with yours one). **Warning**: use this code only as an example,"
#~ " it creates a lots of `QgsRubberBand "
#~ "<http://qgis.org/api/api/classQgsRubberBand.html>`_ objects and may be slow "
#~ "on large datasets."
#~ msgstr ""

#~ msgid "Same thing but using :func:`dijkstra` method::"
#~ msgstr ""

#~ msgid "Finding shortest path"
#~ msgstr ""

#~ msgid ""
#~ "To find optimal path between two points the following approach is used. Both"
#~ " points (start A and end B) are \"tied\" to graph when it builds. Than using"
#~ " methods :func:`shortestTree` or :func:`dijkstra` we build shortest tree "
#~ "with root in the start point A. In the same tree we also found end point B "
#~ "and start to walk through tree from point B to point A. Whole algorithm can "
#~ "be written as::"
#~ msgstr ""

#~ msgid ""
#~ "At this point we have path, in the form of the inverted list of vertices "
#~ "(vertices are listed in reversed order from end point to start one) that "
#~ "will be visited during traveling by this path."
#~ msgstr ""

#~ msgid ""
#~ "Here is the sample code for QGIS Python Console (you will need to select "
#~ "linestring layer in TOC and replace coordinates in the code with yours) that"
#~ " uses method :func:`shortestTree`::"
#~ msgstr ""

#~ msgid "And here is the same sample but using :func:`dikstra` method::"
#~ msgstr ""

#~ msgid "Areas of the availability"
#~ msgstr ""

#~ msgid ""
#~ "Area of availability for vertex A is a subset of graph vertices, that are "
#~ "accessible from vertex A and cost of the path from A to this vertices are "
#~ "not greater that some value."
#~ msgstr ""

#~ msgid ""
#~ "More clearly this can be shown with the following example: \"There is a fire"
#~ " station. What part of city fire command can reach in 5 minutes? 10 minutes?"
#~ " 15 minutes?\". Answers on this questions are fire station's areas of "
#~ "availability."
#~ msgstr ""

#~ msgid ""
#~ "To find areas of availablity we can use method :func:`dijksta` of the "
#~ ":class:`QgsGraphAnalyzer` class. It is enough to compare elements of cost "
#~ "array with predefined value. If cost[ i ] is less or equal than predefined "
#~ "value, than vertex i is inside area of availability, otherwise --- outside."
#~ msgstr ""

#~ msgid ""
#~ "More difficult it is to get borders of area of availablity. Bottom border "
#~ "--- is a set of vertices that are still accessible, and top border --- is a "
#~ "set of vertices which are not accesible. In fact this is simple: "
#~ "availability border passed on such edges of the shortest path tree for which"
#~ " start vertex is accessible and end vertex is not accessible."
#~ msgstr ""

#~ msgid "Here is an example::"
#~ msgstr ""
