# 
# Translators:
# Choro <u.ko.kubot@gmail.com>, 2014-2015
# Kohei Tomita <fairtommy@gmail.com>, 2017
# kosuke.asahi <waigania13@gmail.com>, 2014
# Takayuki Nuimura <nuimura@nagoya-u.jp>, 2013
# Takayuki Nuimura <nuimura@nagoya-u.jp>, 2013
# kosuke.asahi <waigania13@gmail.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-05 22:35\n"
"PO-Revision-Date: 2017-06-19 12:59+0000\n"
"Last-Translator: Kohei Tomita <fairtommy@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/qgis/qgis-documentation/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:9
msgid "Using Vector Layers"
msgstr "ベクターレイヤを使う"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:14
msgid ""
"This section summarizes various actions that can be done with vector layers."
msgstr "このセクションではベクタレイヤに対して行える様々な操作について紹介していきます."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:73
msgid "Iterating over Vector Layer"
msgstr "ベクターレイヤの反復処理"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:130
msgid "Iterating over selected features"
msgstr "選択されたフィーチャへの反復処理"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:158
msgid "Iterating over a subset of features"
msgstr "一部のフィーチャへの反復処理"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:160
msgid ""
"If you want to iterate over a given subset of features in a layer, such as "
"those within a given area, you have to add a :obj:`QgsFeatureRequest` object"
" to the :func:`getFeatures()` call. Here's an example"
msgstr "もし所定の範囲内に含まれフィーチャのように、レイヤ中の所定のフィーチャにのみ処理を行いたい場合、 :obj:`QgsFeatureRequest` オブジェクトを :func:`getFeatures()` に加えます。下記が例になります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:212
msgid "Modifying Vector Layers"
msgstr "ベクターレイヤの修正"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:260
msgid "Add Features"
msgstr "フィーチャの追加"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:283
msgid "Delete Features"
msgstr "フィーチャの削除"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:293
msgid "Modify Features"
msgstr "フィーチャの修正"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:320
msgid "Adding and Removing Fields"
msgstr "フィールドの追加または削除"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:343
msgid "Modifying Vector Layers with an Editing Buffer"
msgstr "ベクターレイヤを編集バッファで修正する."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:345
msgid ""
"When editing vectors within QGIS application, you have to first start "
"editing mode for a particular layer, then do some modifications and finally "
"commit (or rollback) the changes. All the changes you do are not written "
"until you commit them --- they stay in layer's in-memory editing buffer. It "
"is possible to use this functionality also programmatically --- it is just "
"another method for vector layer editing that complements the direct usage of"
" data providers. Use this option when providing some GUI tools for vector "
"layer editing, since this will allow user to decide whether to "
"commit/rollback and allows the usage of undo/redo. When committing changes, "
"all changes from the editing buffer are saved to data provider."
msgstr "QGISアプリケーションでベクターを編集するには、個々のレイヤを編集モードにしてから編集を行って最後に変更をコミット(もしくはロールバック)します。全ての変更はそれらをコミットするまでは書き込まれません --- これらはメモリ上の編集バッファに居続けます。これらの機能はプログラムで扱うことができます　--- これはデータプロバイダを直接使う方法を補完するベクターレイヤを編集する別の方法です。ベクターレイヤの編集機能をもったGUIツールを提供する際にこのオプションを使えば、ユーザにコミット/ロールバックをするのを決めさせられ、またundo/redoのような使い方をさせることができます。変更をコミットする時に、編集バッファの全ての変更はデータプロバイダに保存されます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:426
msgid "Using Spatial Index"
msgstr "空間インデックスを使う"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:474
msgid "Writing Vector Layers"
msgstr "ベクターレイヤの作成"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:476
msgid ""
"You can write vector layer files using :class:`QgsVectorFileWriter` class. "
"It supports any other kind of vector file that OGR supports (shapefiles, "
"GeoJSON, KML and others)."
msgstr ":class:`QgsVectorFileWriter` クラスを使ってベクターレイヤファイルを書き出す事ができます。これはOGRがサポートするいかなるベクターファイル(shapefiles, GeoJSON, KML そしてその他)をサポートしています。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:480
msgid "There are two possibilities how to export a vector layer:"
msgstr "ベクターレイヤをエクスポートする方法は二つあります:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:543
msgid "Memory Provider"
msgstr "メモリープロバイダー"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:545
msgid ""
"Memory provider is intended to be used mainly by plugin or 3rd party app "
"developers. It does not store data on disk, allowing developers to use it as"
" a fast backend for some temporary layers."
msgstr "メモリープロバイダーはプラグインやサードパーティアプリケーション開発者に主に使われるでしょう。これはディスクにデータを保存せず、開発者がテンポラリなレイヤーの高速なバックエンドとして使えるようになります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:549
msgid "The provider supports string, int and double fields."
msgstr "プロバイダは文字列と int と double をサポートします。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:551
msgid ""
"The memory provider also supports spatial indexing, which is enabled by "
"calling the provider's :func:`createSpatialIndex` function. Once the spatial"
" index is created you will be able to iterate over features within smaller "
"regions faster (since it's not necessary to traverse all the features, only "
"those in specified rectangle)."
msgstr "メモリープロバイダーは空間インデックスもサポートしていて、プロバイダーの :func:`createSpatialIndex` を呼ぶことで有効になります。一度空間インデックスを作成したら小さい領域内でフィーチャのiterateが高速にできるようになります(これ以降は全てのフィーチャを順にたどる必要がなくなり、指定した短形内で収まります)。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:557
msgid ""
"A memory provider is created by passing ``\"memory\"`` as the provider "
"string to the :class:`QgsVectorLayer` constructor."
msgstr "メモリープロバイダーは :class:`QgsVectorLayer` のコンストラクタに ``\"memory\"`` をプロバイダーの文字列として与えると作成されます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:560
msgid ""
"The constructor also takes a URI defining the geometry type of the layer, "
"one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
"``\"MultiPoint\"``, ``\"MultiLineString\"``, or ``\"MultiPolygon\"``."
msgstr "コンストラクタはレイヤーのジオメトリの種類に指定したURLを与えることができます。この種類は次のものです: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, ``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` ."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:564
msgid ""
"The URI can also specify the coordinate reference system, fields, and "
"indexing of the memory provider in the URI. The syntax is:"
msgstr "URIではメモリープロバイダーの座標参照系、属性フィールド、インデックスを指定することが出来ます。構文は、"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:569
msgid "crs=definition"
msgstr "crs=definition"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:568
msgid ""
"Specifies the coordinate reference system, where definition may be any of "
"the forms accepted by :func:`QgsCoordinateReferenceSystem.createFromString`"
msgstr "座標参照系を指定し、この定義は :func:`QgsCoordinateReferenceSystem.createFromString` で受け付ける事ができるどんな値でも置くことができます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:572
msgid "index=yes"
msgstr "index=yes"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:572
msgid "Specifies that the provider will use a spatial index"
msgstr "プロバイダーが空間インデックスを使うことを指定します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:577
msgid "field=name:type(length,precision)"
msgstr "field=name:type(length,precision)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:575
msgid ""
"Specifies an attribute of the layer.  The attribute has a name, and "
"optionally a type (integer, double, or string), length, and precision. There"
" may be multiple field definitions."
msgstr "レイヤーの属性を指定します。属性は名前を持ち、オプションとして種類(integer, double, string)、長さと正確性を持ちます。複数のフィールドの定義を置くことになるでしょう。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:628
msgid "Appearance (Symbology) of Vector Layers"
msgstr "ベクタレイヤーの外観(シンボロジ)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:630
msgid ""
"When a vector layer is being rendered, the appearance of the data is given "
"by **renderer** and **symbols** associated with the layer.  Symbols are "
"classes which take care of drawing of visual representation of features, "
"while renderers determine what symbol will be used for a particular feature."
msgstr "ベクタレイヤーがレンダリングされるとき、データの外観はレイヤーによって関連付けられた **レンダラー** と **シンボル** によって決定されます。シンボルはフィーチャの仮想的な表現を描画するクラスで、レンダラーはシンボルが個々のフィーチャで使われるかを決定します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:635
msgid "The renderer for a given layer can obtained as shown below:"
msgstr "指定したレイヤのレンダラーは下記のように得ることが出来ます"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:647
msgid "There are several known renderer types available in QGIS core library:"
msgstr "次の表は QGIS コアライブラリに存在するいくつかのよく知られたレンダラーです:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:650
msgid "Type"
msgstr "タイプ"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:650
msgid "Class"
msgstr "クラス"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:650
msgid "Description"
msgstr "詳細"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:652
msgid "singleSymbol"
msgstr "singleSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:652
msgid ":class:`QgsSingleSymbolRendererV2`"
msgstr ":class:`QgsSingleSymbolRendererV2`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:652
msgid "Renders all features with the same symbol"
msgstr "全てのフィーチャを同じシンボルでレンダーします"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:653
msgid "categorizedSymbol"
msgstr "categorizedSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:653
msgid ":class:`QgsCategorizedSymbolRendererV2`"
msgstr ":class:`QgsCategorizedSymbolRendererV2`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:653
msgid "Renders features using a different symbol for each category"
msgstr "カテゴリごとに違うシンボルを使ってフィーチャをレンダーします"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:654
msgid "graduatedSymbol"
msgstr "graduatedSymbol"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:654
msgid ":class:`QgsGraduatedSymbolRendererV2`"
msgstr ":class:`QgsGraduatedSymbolRendererV2`"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:654
msgid "Renders features using a different symbol for each range of values"
msgstr "それぞれの範囲の値によって違うシンボルを使ってフィーチャをレンダーします"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:683
msgid ""
"You can get the symbol used for rendering by calling :func:`symbol` method "
"and change it with :func:`setSymbol` method (note for C++ devs: the renderer"
" takes ownership of the symbol.)"
msgstr "レンダリングが使っているシンボルは :func:`symbol` メソッドで取得することができ、 :func:`setSymbol` メソッドで変更することができます(C++開発者へメモ: レンダラーはシンボルのオーナーシップをとります)。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:761
msgid ""
"You can query and set attribute name which is used for classification: use "
":func:`classAttribute` and :func:`setClassAttribute` methods."
msgstr "分類するのに使われる属性名を検索したりセットしたりすることができます: :func:`classAttribute` メソッドと :func:`setClassAttribute` メソッドを使います。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:771
msgid ""
"Where :func:`value` is the value used for discrimination between categories,"
" :func:`label` is a text used for category description and :func:`symbol` "
"method returns assigned symbol."
msgstr ":func:`value` はカテゴリを区別にするのに使う値で、 :func:`label` はカテゴリの詳細に使われるテキストで、 :func:`symbol` メソッドは割り当てられているシンボルを返します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:775
msgid ""
"The renderer usually stores also original symbol and color ramp which were "
"used for the classification: :func:`sourceColorRamp` and "
":func:`sourceSymbol` methods."
msgstr "レンダラはたいていオリジナルのシンボルと識別をするためにカラーランプを保持しています: :func:`sourceColorRamp` メソッドと :func:`sourceSymbol` メソッドから呼び出せます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:783
msgid ""
"This renderer is very similar to the categorized symbol renderer described "
"above, but instead of one attribute value per class it works with ranges of "
"values and thus can be used only with numerical attributes."
msgstr "このレンダラは先ほど暑かったカテゴリ分けシンボルのレンダラととても似ていますが、クラスごとの一つの属性値の代わりに領域の値として動作し、そのため数字の属性のみ使うことができます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:799
msgid ""
"you can again use :func:`classAttribute` to find out classification "
"attribute name, :func:`sourceSymbol` and :func:`sourceColorRamp` methods.  "
"Additionally there is :func:`mode` method which determines how the ranges "
"were created: using equal intervals, quantiles or some other method."
msgstr "属性名の分類を調べるために :func:`classAttribute` をまた使うことができ、 :func:`sourceSymbol` メソッドと :func:`sourceColorRamp` メソッドも使うことができます。さらに作成された領域の測定する :func:`mode` メソッドもあります: 等間隔や変位値、その他のメソッドと一緒に使います。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:850
msgid ""
"For representation of symbols, there is :class:`QgsSymbolV2` base class with"
" three derived classes:"
msgstr "シンボルを表現するには、 :class:`QgsSymbolV2` ベースクラス由来の三つの派生クラスを使います:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:857
msgid ""
"**Every symbol consists of one or more symbol layers** (classes derived from"
" :class:`QgsSymbolLayerV2`). The symbol layers do the actual rendering, the "
"symbol class itself serves only as a container for the symbol layers."
msgstr "**全てのシンボルは一つ以上のシンボルレイヤーから構成されます** (:class:`QgsSymbolLayerV2` の派生クラスです)。シンボルレイヤーは実際にレンダリングをして、シンボルクラス自信はシンボルレイヤのコンテナを提供するだけです。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:872
msgid ""
"To find out symbol's color use :func:`color` method and :func:`setColor` to "
"change its color. With marker symbols additionally you can query for the "
"symbol size and rotation with :func:`size` and :func:`angle` methods, for "
"line symbols there is :func:`width` method returning line width."
msgstr "シンボルが使っている色を得るには :func:`color` メソッドを使い、 :func:`setColor` でシンボルの色を変えます。マーカーシンボルは他にもシンボルのサイズと回転角をそれぞれ :func:`size` メソッドと :func:`angle` メソッドで取得することができ、ラインシンボルは :func:`width` メソッドでラインの幅を返します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:877
msgid "Size and width are in millimeters by default, angles are in degrees."
msgstr "サイズと幅は標準でミリメートルが使われ、角度は 度 が使われます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:884
msgid ""
"As said before, symbol layers (subclasses of :class:`QgsSymbolLayerV2`) "
"determine the appearance of the features.  There are several basic symbol "
"layer classes for general use. It is possible to implement new symbol layer "
"types and thus arbitrarily customize how features will be rendered. The "
":func:`layerType` method uniquely identifies the symbol layer class --- the "
"basic and default ones are SimpleMarker, SimpleLine and SimpleFill symbol "
"layers types."
msgstr "前に述べたようにシンボルレイヤ(:class:`QgsSymbolLayerV2` のサブクラスです) はフィーチャの外観を決定します。一般的に使われるいくつかの基本となるシンボルレイヤのクラスがあります。これは新しいシンボルレイヤの種類を実装を可能とし、それによってフィーチャがどのようにレンダーされるかを任意にカスタマイズできます。 :func:`layerType` メソッドはシンボルレイヤクラスの一意に識別します --- 基本クラスは標準で SimpleMarker 、 SimpleLine 、 SimpleFill がシンボルレイヤのタイプとなります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:912
msgid ""
":class:`QgsSymbolLayerV2Registry` class manages a database of all available "
"symbol layer types."
msgstr ":class:`QgsSymbolLayerV2Registry` クラスは利用可能な全てのシンボルレイヤタイプのデータベースを管理しています。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:915
msgid ""
"To access symbol layer data, use its :func:`properties` method that returns "
"a key-value dictionary of properties which determine the appearance. Each "
"symbol layer type has a specific set of properties that it uses. "
"Additionally, there are generic methods :func:`color`, :func:`size`, "
":func:`angle`, :func:`width` with their setter counterparts. Of course size "
"and angle is available only for marker symbol layers and width for line "
"symbol layers."
msgstr "シンボルレイヤのデータにアクセスするには、 :func:`properties` メソッドを使い、これは表現方法を決定しているプロパティの辞書のキー値を返します。それぞれのシンボルレイヤタイプはそれが使っている特定のプロパティの集合を持っています。さらに、共通して使えるメソッドとして :func:`color`, :func:`size`, :func:`angle`, :func:`width` がそれぞれセッターと対応して存在します。もちろん size と angle はマーカーシンボルレイヤだけで利用可能で、 width はラインシンボルレイヤだけで利用可能です。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:964
msgid ""
"The :func:`layerType` method determines the name of the symbol layer, it has"
" to be unique among all symbol layers. Properties are used for persistence "
"of attributes. :func:`clone` method must return a copy of the symbol layer "
"with all attributes being exactly the same. Finally there are rendering "
"methods: :func:`startRender` is called before rendering first feature, "
":func:`stopRender` when rendering is done. And :func:`renderPoint` method "
"which does the rendering. The coordinates of the point(s) are already "
"transformed to the output coordinates."
msgstr ":func:`layerType` メソッドはシンボルレイヤーの名前を決定し、全てのシンボルレイヤーの中で一意になります。プロパティは属性の持続として使われます。 :func:`clone` メソッドは全ての全く同じ属性を含んだシンボルレイヤーのコピーを返さなくてはなりません。最後にレンダリングのメソッドについて: :func:`startRender` はフィーチャが最初にレンダリングされる前に呼び出され、 :func:`stopRender` はレンダリングが終わったら呼び出されます。そして :func:`renderPoint` メソッドでレンダリングを行います。ポイントの座標は出力対象の座標に常に変換されます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:973
msgid ""
"For polylines and polygons the only difference would be in the rendering "
"method: you would use :func:`renderPolyline` which receives a list of lines,"
" resp. :func:`renderPolygon` which receives list of points on outer ring as "
"a first parameter and a list of inner rings (or None) as a second parameter."
msgstr "ポリラインとポリゴンではレンダリングのメソッドが違うだけです: (ポリラインでは)それぞれのラインの配列を受け取る :func:`renderPolyline` を使います。 :func:`renderPolygon` は最初のパラメータを外輪としたポイントのリストと、２つ目のパラメータに内輪(もしくは None)のリストを受け取ります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1014
msgid ""
"This widget can be embedded into the symbol properties dialog. When the "
"symbol layer type is selected in symbol properties dialog, it creates an "
"instance of the symbol layer and an instance of the symbol layer widget. "
"Then it calls :func:`setSymbolLayer` method to assign the symbol layer to "
"the widget. In that method the widget should update the UI to reflect the "
"attributes of the symbol layer. :func:`symbolLayer` function is used to "
"retrieve the symbol layer again by the properties dialog to use it for the "
"symbol."
msgstr "このwidgetはシンボルプロパティのダイアログに組み込むことができます。シンボルプロパティのダイアログでシンボルレイヤータイプを選択したときにこれはシンボルレイヤーのインスタンスとシンボルレイヤー widget のインスタンスを作成します。そしてwidgetをシンボルレイヤーを割り当てるために :func:`setSymbolLayer` メソッドを呼び出します。このメソッドでwidgetがシンボルレイヤーの属性を反映するようUIを更新します。 :func:`symbolLayer` 関数はシンボルが使ってるプロパティダイアログがシンボルレイヤーを再度探すのに使われます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1022
msgid ""
"On every change of attributes, the widget should emit :func:`changed()` "
"signal to let the properties dialog update the symbol preview."
msgstr "いかなる属性の変更時でも、プロパティダイアログにシンボルプレビューを更新させるために widget は :func:`changed()` シグナルを発生します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1025
msgid ""
"Now we are missing only the final glue: to make QGIS aware of these new "
"classes. This is done by adding the symbol layer to registry. It is possible"
" to use the symbol layer also without adding it to the registry, but some "
"functionality will not work: e.g. loading of project files with the custom "
"symbol layers or inability to edit the layer's attributes in GUI."
msgstr "私達は最後につなげるところだけまだ扱っていません: QGIS にこれらの新しいクラスを知らせる方法です。これはレジストリにシンボルレイヤーを追加すれば完了です。レジストリに追加しなくてもシンボルレイヤーを使うことはできますが、いくつかの機能が動かないでしょう: 例えばカスタムシンボルレイヤーを使ってプロジェクトファイルを読み込んだり、GUIでレイヤーの属性を編集できないなど。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1049
msgid ""
"You should pass layer type (the same as returned by the layer) and symbol "
"type (marker/line/fill) to the constructor of parent class. "
":func:`createSymbolLayer` takes care of creating an instance of symbol layer"
" with attributes specified in the `props` dictionary. (Beware, the keys are "
"QString instances, not \"str\" objects). And there is "
":func:`createSymbolLayerWidget` method which returns settings widget for "
"this symbol layer type."
msgstr "レイヤータイプ(レイヤーが返すのと同じもの)とシンボルタイプ(marker/line/fill)を親クラスのコンストラクタに渡します。 :func:`createSymbolLayer` は辞書の引数の `props` で指定した属性をもつシンボルレイヤーのインスタンスを作成をしてくれます。 (キー値は QString のインスタンスで、決して \"str\" のオブジェクトではないのに気をつけましょう) そして :func:`createSymbolLayerWidget` メソッドはこのシンボルレイヤータイプの設定 widget を返します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1056
msgid ""
"The last step is to add this symbol layer to the registry --- and we are "
"done."
msgstr "最後にこのシンボルレイヤーをレジストリに追加します --- これで完了です。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1064
msgid ""
"It might be useful to create a new renderer implementation if you would like"
" to customize the rules how to select symbols for rendering of features. "
"Some use cases where you would want to do it: symbol is determined from a "
"combination of fields, size of symbols changes depending on current scale "
"etc."
msgstr "もしシンボルがフィーチャのレンダリングをどう行うかをカスタマイズしたいのであれば、新しいレンダラーの実装を作ると便利かもしれません。いくつかのユースケースとしてこんなことをしたいのかもしれません: フィールドの組み合わせからシンボルを決定する、現在の縮尺に合わせてシンボルのサイズを変更するなどなど。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1098
msgid ""
"The constructor of parent :class:`QgsFeatureRendererV2` class needs renderer"
" name (has to be unique among renderers). :func:`symbolForFeature` method is"
" the one that decides what symbol will be used for a particular feature. "
":func:`startRender` and :func:`stopRender` take care of "
"initialization/finalization of symbol rendering. :func:`usedAttributes` "
"method can return a list of field names that renderer expects to be present."
" Finally :func:`clone` function should return a copy of the renderer."
msgstr "親クラスの :class:`QgsFeatureRendererV2` のコンストラクタはレンダラの名前(レンダラの中で一意になる必要があります)が必要です。 :func:`symbolForFeature` メソッドは個々のフィーチャでどのシンボルが使われるかを一つ決定します。 :func:`startRender` と :func:`stopRender` それぞれシンボルのレンダリングの初期化/終了を処理します。 :func:`usedAttributes` メソッドはレンダラが与えられるのを期待するフィールド名のリストを返すことができます。最後に :func:`clone` 関数はレンダラーのコピーを返すでしょう。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1137
msgid ""
"The constructor receives instances of the active layer "
"(:class:`QgsVectorLayer`), the global style (:class:`QgsStyleV2`) and "
"current renderer. If there is no renderer or the renderer has different "
"type, it will be replaced with our new renderer, otherwise we will use the "
"current renderer (which has already the type we need). The widget contents "
"should be updated to show current state of the renderer. When the renderer "
"dialog is accepted, widget's :func:`renderer` method is called to get the "
"current renderer --- it will be assigned to the layer."
msgstr "コンストラクタはアクティブなレイヤー(:class:`QgsVectorLayer`)とグローバルなスタイル(:class:`QgsStyleV2`)と現在のレンダラのインスタンスを受け取ります。もしレンダラが無かったり、レンダラが違う種類のものだったら、コンストラクタは新しいレンダラに差し替えるか、そうでなければ現在のレンダラー(必要な種類を持つでしょう)を使います。widgetの中身はレンダラーの現在の状態を表示するよう更新されます。レンダラダイアログが受け入れられたときに、現在のレンダラを取得するために widget の :func:`renderer` メソッドが呼び出されます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1164
msgid ""
"Similarly as with symbol layers, abstract metadata constructor awaits "
"renderer name, name visible for users and optionally name of renderer's "
"icon. :func:`createRenderer` method passes :class:`QDomElement` instance "
"that can be used to restore renderer's state from DOM tree. "
":func:`createRendererWidget` method creates the configuration widget. It "
"does not have to be present or can return `None` if the renderer does not "
"come with GUI."
msgstr "シンボルレイヤーと同様に、abstract metadataのコンストラクタはレンダラの名前を受け取るのを期待して、この名前はユーザに見え、レンダラのアイコンの追加の名前となります。 :func:`createRenderer` メソッドには :class:`QDomElement` のインスタンスを渡してレンダラの状態を DOM ツリーから復元するのに使います。 :func:`createRendererWidget` メソッドは設定のwidgetを作成します。これは必ず存在する必要はなく、もしレンダラがGUIからいじらないのであれば `None` を返すことができます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1183
msgid ""
"The icon can be associated also at any later time using :func:`setIcon` "
"method of the metadata class. The icon can be loaded from a file (as shown "
"above) or can be loaded from a `Qt resource "
"<http://qt.nokia.com/doc/4.5/resources.html>`_ (PyQt4 includes .qrc compiler"
" for Python)."
msgstr "アイコンはあとからメタデータクラスの :func:`setIcon` を使って関連付けることもできます。アイコンはファイルから読み込むこと(上記を参考)も `Qt のリソース <http://qt.nokia.com/doc/4.5/resources.html>`_ から読み込むこともできます(PyQt4 はパイソン向けの .qrc コンパイラを含んでいます)。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1197
msgid "**TODO:**"
msgstr "**TODO:**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:16
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:34
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:69
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:207
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:471
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:625
msgid "vector layers"
msgstr "ベクターレイヤー"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:69
msgid "iterating"
msgstr "反復処理"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:16
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:34
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:69
msgid "features"
msgstr "フィーチャー"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:207
msgid "editing"
msgstr "編集"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:423
msgid "spatial index"
msgstr "空間インデックス"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:423
msgid "using"
msgstr "使用する"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:471
msgid "writing"
msgstr "書き込み"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:540
msgid "memory provider"
msgstr "メモリープロバイダー"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:625
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:678
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:756
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:778
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1199
msgid "symbology"
msgstr "シンボロジー"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:678
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:678
msgid "single symbol renderer"
msgstr "single symbol renderer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:756
msgid "categorized symbology renderer"
msgstr "categorized symbology renderer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:756
msgid "categorized symbol renderer"
msgstr "categorized symbol renderer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:778
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:778
msgid "graduated symbol renderer"
msgstr "graduated symbol renderer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:845
msgid "symbols"
msgstr "シンボル"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:845
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:879
msgid "working with"
msgstr "作業"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:879
#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:922
msgid "symbol layers"
msgstr "シンボルレイヤ"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:922
msgid "creating custom types"
msgstr "カスタムタイプの作成"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1058
msgid "custom"
msgstr "カスタム"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1058
msgid "renderers"
msgstr "レンダラー"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1199
msgid "old"
msgstr "旧"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:20
msgid "Retrieving information about attributes"
msgstr "属性に関する情報を取得します"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:22
msgid ""
"You can retrieve information about the fields associated with a vector layer"
" by calling :func:`pendingFields` on a :class:`QgsVectorLayer` instance::"
msgstr ":class:`QgsVectorLayer`インスタンス上:func:`pendingFields`を呼び出すことにより、ベクトルレイヤーに関連付けられたフィールドに関する情報を取得できます::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:30
msgid ""
"Starting from QGIS 2.12 there is also a :func:`fields()` in "
":class:`QgsVectorLayer` which is an alias to :func:`pendingFields`."
msgstr "QGIS 2.12から出発する、こともある:class:`QgsVectorLayer`中の:func:`fields()`もある、:func:`pendingFields`の別名である。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:38
msgid "Selecting features"
msgstr "フィーチャの選択"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:40
msgid ""
"In QGIS desktop, features can be selected in different ways, the user can "
"click on a feature, draw a rectangle on the map canvas or use an expression "
"filter. Selected features are normally highlighted in a different color "
"(default is yellow) to draw user's attention on the selection. Sometimes can"
" be useful to programmatically select features or to change the default "
"color."
msgstr "QGISデスクトップでは、地物はいろいろな方法で選択できます。ユーザーは地物をクリックしても、地図キャンバス上で長方形を描いても、表現フィルタを使用てもよいです。 選択された地物は、選択に関してユーザーの注意をひくために、通常は異なる色（デフォルトは黄色です）で強調表示されます。 プログラム的に地物を選択するとか、デフォルト色を変更すると役に立つこともあります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:47
msgid ""
"To change the selection color you can use :func:`setSelectionColor()` method"
" of :class:`QgsMapCanvas` as shown in the following example::"
msgstr "選択色を変更するには、次の例に示すように、 :class:`QgsMapCanvas`の:func:`setSelectionColor() `メソッドを使用できます::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:53
msgid ""
"To add add features to the selected features list for a given layer, you can"
" call :func:`setSelectedFeatures()` passing to it the list of features IDs::"
msgstr "所定のレイヤーのために選択した地物のリストに地物を追加するには、:func:`setSelectedFeatures()`を、地物のIDのリストをそれに渡しつつ呼び出すことができます::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:63
msgid "To clear the selection, just pass an empty list::"
msgstr "選択を解除するため、空のリストを通ります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:75
msgid ""
"Iterating over the features in a vector layer is one of the most common "
"tasks. Below is an example of the simple basic code to perform this task and"
" showing some information about each feature. the ``layer`` variable is "
"assumed to have a :class:`QgsVectorLayer` object"
msgstr "ベクターレイヤのフィーチャへの反復処理はもっとも頻繁に行う処理の一つです。次の例はこの処理を行う基本的なコードで、各フィーチャのいくつかの情報を表示します。 ``layer`` はQGSVectorLayerオブジェクトとしています。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:112
msgid "Accessing attributes"
msgstr "属性のアクセス"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:114
msgid "Attributes can be referred to by their name."
msgstr "属性は、それらの名称によって参照されます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:120
msgid ""
"Alternatively, attributes can be referred to by index. This is will be a bit"
" faster than using the name. For example, to get the first attribute:"
msgstr "あるいは、属性はインデックスに参照されます。これは名称を使うよりもやや高速です。たとえば、新しい属性を取得するためです:"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:132
msgid ""
"if you only need selected features, you can use the :func:`selectedFeatures`"
" method from vector layer:"
msgstr "地物を選択する必要のみある場合、 ベクタレイヤから :func: `selectedFeatures` メソッドを使用できます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:143
msgid "Another option is the Processing :func:`features` method:"
msgstr "別のオプションは、処理:func:`features`メソッドです："

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:152
msgid ""
"By default, this will iterate over all the features in the layer, in case "
"there is no selection, or over the selected features otherwise. Note that "
"this behavior can be changed in the Processing options to ignore selections."
msgstr "デフォルトでは、これは、選択がない場合はレイヤー中のすべての地物について、そうでない場合は選択されたすべての地物について繰り返します。 このふるまいは選択を無視するように「処理」オプションで変更できることに注意。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:172
msgid ""
"If you need an attribute-based filter instead (or in addition) of a spatial "
"one like shown in the example above, you can build an :obj:`QgsExpression` "
"object and pass it to the :obj:`QgsFeatureRequest` constructor. Here's an "
"example"
msgstr "上記の例に示すように、空間フィルタの代わりに（あるいは加えて）属性ベースのフィルタが必要な場合は、:obj:`QgsExpression`オブジェクトを構築し、それを:obj:` QgsFeatureRequest`コンストラクタに渡すことができます。ここに例があります"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:184
msgid ""
"See :ref:`expressions` for the details about the syntax supported by "
":class:`QgsExpression`."
msgstr ":class:`QgsExpression`によってサポートされる構文の詳細については、:ref:`expressions`を参照。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:186
msgid ""
"The request can be used to define the data retrieved for each feature, so "
"the iterator returns all features, but returns partial data for each of "
"them."
msgstr "要求は、地物ごとに取得したデータを定義するために使用できるので、反復子はすべての地物を返しますが、それぞれの地物については部分的データを返します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:201
msgid ""
"If you only need a subset of the attributes or you don't need the geometry "
"information, you can significantly increase the **speed** of the features "
"request by using ``QgsFeatureRequest.NoGeometry`` flag or specifying a "
"subset of attributes (possibly empty) like shown in the example above."
msgstr "属性の部分集合だけ必要な場合、または幾何情報を必要としない場合は、上の例で示されるように「QgsFeatureRequest.NoGeometry」フラグを使用するか属性の部分集合（空も可能）を指定することによって、地物要求の**速度**をかなり向上できます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:214
msgid ""
"Most vector data providers support editing of layer data. Sometimes they "
"support just a subset of possible editing actions. Use the "
":func:`capabilities` function to find out what set of functionality is "
"supported"
msgstr "ベクトルデータプロバイダはほとんどレイヤーデータの編集をサポートします。時には彼らは、可能な編集操作の一部分だけをサポートしています。機能のどの部分がサポートされるかを見つけるために :func:`capabilities`関数を使用します"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:225
msgid ""
"For a list of all available capabilities, please refer to the `API "
"Documentation of QgsVectorDataProvider "
"<http://qgis.org/api/classQgsVectorDataProvider.html>`_"
msgstr "利用可能なすべての機能のリストについては、`QgsVectorDataProviderのAPIドキュメント<http://qgis.org/api/classQgsVectorDataProvider.html> ` _を参照してください"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:228
msgid ""
"To print layer's capabilities textual description in a comma separated list "
"you can use :func:`capabilitiesString` as in the following example::"
msgstr "カンマ区切りリストでレイヤーの機能の説明テキストを印刷するには、次の例のように :func:`capabilitiesString` が使用できます::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:238
msgid ""
"By using any of the following methods for vector layer editing, the changes "
"are directly committed to the underlying data store (a file, database etc). "
"In case you would like to do only temporary changes, skip to the next "
"section that explains how to do :ref:`modifications with editing buffer "
"<editing-buffer>`."
msgstr "ベクターレイヤを編集するための以下の方法のいずれかを使用することで、変更は直接基礎となるデータストア（ファイル、データベースなど）にコミットされます。一時的な変更をしたいだけの場合は、どうするかを説明している次のセクション:ref:`編集バッファーで修正する`に跳んでください。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:246
msgid ""
"If you are working inside QGIS (either from the console or from a plugin), "
"it might be necessary to force a redraw of the map canvas in order to see "
"the changes you've done to the geometry, to the style or to the attributes::"
msgstr "QGISの内部（コンソールまたはプラグインからのいずれか）で作業している場合、ジオメトリ、スタイル、属性に行われた変更を確認するため、地図キャンバスを強制的に再描画することが必要になることもあるでしょう::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:262
msgid ""
"Create some :class:`QgsFeature` instances and pass a list of them to "
"provider's :func:`addFeatures` method. It will return two values: result "
"(true/false) and list of added features (their ID is set by the data store)."
msgstr "いくつか:class: `QgsFeature`インスタンスを作成し、プロバイダの:func:`addFeatures`メソッドにそれらのリストを渡します。これは、2つの値を返します。結果（真/偽）および追加された地物のリスト（それらのIDはデータストアによって設定されます）。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:266
msgid ""
"To set up the attributes you can either initialize the feature passing a "
":class:`QgsFields` instance or call :func:`initAttributes` passing the "
"number of fields you want to be added."
msgstr "属性を設定するには、:class: `QgsFields`インスタンスを渡して地物を初期化することも、追加したいフィールドの数を渡して`:func:initAttributes`を呼び出すこともできます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:285
msgid "To delete some features, just provide a list of their feature IDs"
msgstr "フィーチャを削除するには、フィーチャのIDの配列を渡すだけです::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:295
msgid ""
"It is possible to either change feature's geometry or to change some "
"attributes. The following example first changes values of attributes with "
"index 0 and 1, then it changes the feature's geometry"
msgstr "フィーチャのジオメトリの変更も属性の変更もどちらも可能です。次のサンプルは最初にインデックス 0 と 1 の属性の値を変更し、その後にフィーチャのジオメトリを変更しています"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:314
msgid ""
"If you only need to change geometries, you might consider using the "
":class:`QgsVectorLayerEditUtils` which provides some of useful methods to "
"edit geometries (translate, insert or move vertex etc.)"
msgstr "ジオメトリを変更する必要があるだけの場合は、:class:`QgsVectorLayerEditUtils`を使用することを考えてもよいでしょう。これはジオメトリを編集するための有用なメソッドをいくつか提供します（変換、移動、頂点挿入など）。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:322
msgid ""
"To add fields (attributes), you need to specify a list of field definitions."
" For deletion of fields just provide a list of field indexes."
msgstr "フィールド(属性)を追加するには、フィールドの定義の配列を指定する必要があります。フィールドを削除するにはフィールドのインデックスの配列を渡すだけです "

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:333
msgid ""
"After adding or removing fields in the data provider the layer's fields need"
" to be updated because the changes are not automatically propagated."
msgstr "データプロバイダのフィールドを追加または削除した後、レイヤのフィールドは、変更が自動的に反映されていないため、更新する必要があります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:356
msgid ""
"To find out whether a layer is in editing mode, use :func:`isEditable` --- "
"the editing functions work only when the editing mode is turned on. Usage of"
" editing functions"
msgstr "レイヤーが編集モードであるかどうかを調べるには、:func:`isEditable`を使用します---編集機能は、編集モードがオンになっている場合にのみ動作します。編集機能の使用方法"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:377
msgid ""
"In order to make undo/redo work properly, the above mentioned calls have to "
"be wrapped into undo commands. (If you do not care about undo/redo and want "
"to have the changes stored immediately, then you will have easier work by "
":ref:`editing with data provider <editing>`.) How to use the undo "
"functionality"
msgstr "適切に undo/redo が動くようにするには、上記で言及しているコマンドを undo コマンドでラップする必要があります。(もし undo/redo を気にしないで、逐一変更を保存するのであれば、 :ref:`データプロバイダでの編集 <editing>` で簡単に実現できるでしょう。) undo機能はこのように使います"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:396
msgid ""
"The :func:`beginEditCommand` will create an internal \"active\" command and "
"will record subsequent changes in vector layer. With the call to "
":func:`endEditCommand` the command is pushed onto the undo stack and the "
"user will be able to undo/redo it from GUI. In case something went wrong "
"while doing the changes, the :func:`destroyEditCommand` method will remove "
"the command and rollback all changes done while this command was active."
msgstr ":func:`beginEndCommand` は内部的に \"アクティブな\" コマンドを作成して、この後に続くベクターレイヤの変更を記録し続けます。　:func:`endEditCommand` を呼び出すことでundoスタックにコマンドがプッシュされ、ユーザがGUIからコマンドの undo/redo が可能になります。変更をしている途中でなにか問題が発生した場合は、 :func:`destroyEditCommand` メソッドでコマンドを削除してコマンドがアクティブであった時に行った全ての変更をロールバックするでしょう。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:403
msgid ""
"To start editing mode, there is :func:`startEditing()` method, to stop "
"editing there are :func:`commitChanges()` and :func:`rollBack()` --- however"
" normally you should not need these methods and leave this functionality to "
"be triggered by the user."
msgstr "編集モードを開始するには、:func:`startEditing()`メソッドがあり、編集を中止するには:func:`CommitChanges()`と:func:`ROLLBACK()` があります---しかし、通常はこれらのメソッドを必要はありませんし、この機能はユーザによってトリガーされるように残します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:408
msgid ""
"You can also use the :code:`with edit(layer)`-statement to wrap commit and "
"rollback into a more semantic code block as shown in the example below:"
msgstr "次の例に示すように、よりセマンティックなコードブロックにコミットとロールバックをラップする `` - :code:`with edit(layer)`文も使用できます："

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:419
msgid ""
"This will automatically call :func:`commitChanges()` in the end. If any "
"exception occurs, it will :func:`rollBack()` all the changes. In case a "
"problem is encountered within :func:`commitChanges()` (when the method "
"returns False) a :class:`QgsEditError` exception will be raised."
msgstr "これは最後には:func:`CommitChanges()`を自動的に呼び出します。いずれかの例外が発生した場合、それはすべての変更を:func:`rollBack()`します。:func:`CommitChanges()`中で問題に遭遇した場合（メソッドがfalseを返すとき）、:class:`QgsEditError`例外が発生します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:428
msgid ""
"Spatial indexes can dramatically improve the performance of your code if you"
" need to do frequent queries to a vector layer. Imagine, for instance, that "
"you are writing an interpolation algorithm, and that for a given location "
"you need to know the 10 closest points from a points layer, in order to use "
"those point for calculating the interpolated value. Without a spatial index,"
" the only way for QGIS to find those 10 points is to compute the distance "
"from each and every point to the specified location and then compare those "
"distances. This can be a very time consuming task, especially if it needs to"
" be repeated for several locations. If a spatial index exists for the layer,"
" the operation is much more effective."
msgstr "空間インデックスは、頻繁にベクターレイヤーに問い合わせをする必要がある場合、コードのパフォーマンスを劇的に改善します。例えば、補間アルゴリズムを書いていて、補間値の計算に使用するために与えられた位置に対して最も近い10点をポイントレイヤーから求める必要がある、と想像してください。空間インデックスが無いと、QGISがこれらの10点を求める方法は、すべての点から指定の場所への距離を計算してそれらの距離を比較することしかありません。これは、いくつかの場所について繰り返す必要がある場合は特に、非常に時間のかかる処理となります。もし空間インデックスがレイヤに作成されていれば、処理はもっと効率的になります。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:439
msgid ""
"Think of a layer without a spatial index as a telephone book in which "
"telephone numbers are not ordered or indexed. The only way to find the "
"telephone number of a given person is to read from the beginning until you "
"find it."
msgstr "空間インデックスの無いレイヤは、電話番号が順番に並んでいない、もしくはインデックスの無い電話帳と思ってください。所定の人の電話番号を見つける唯一の方法は、巻頭からその番号を見つけるまで読むだけです。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:443
msgid ""
"Spatial indexes are not created by default for a QGIS vector layer, but you "
"can create them easily. This is what you have to do:"
msgstr "空間索引は、QGISベクトルレイヤーのためにデフォルトで作成されていませんが、簡単に作成できます。しなければいけないことはこうです："

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:446
msgid "create spatial index --- the following code creates an empty index"
msgstr "空間インデックスを作成する --- 以下のコードは空のインデックスを作成する"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:454
msgid ""
"add features to index --- index takes :class:`QgsFeature` object and adds it"
msgstr "クラス：インデックスに地物を追加---インデックスは `QgsFeature`オブジェクトをとり、それを追加します"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:453
msgid ""
"to the internal data structure. You can create the object manually or use "
"one from previous call to provider's :func:`nextFeature()`"
msgstr "内部データ構造に。オブジェクトは手動でも作成できますし、プロバイダの:func: ` nextFeature()`の前回の呼び出しからのものも使用できます。："

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:460
msgid "once spatial index is filled with some values, you can do some queries"
msgstr "空間インデックスに何かしらの値が入れられると検索ができるようになります"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:482
msgid "from an instance of :class:`QgsVectorLayer`"
msgstr ":class:`QgsVectorLayer` インスタンスから"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:508
msgid "directly from features"
msgstr "フィーチャから直接"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:579
msgid "The following example of a URI incorporates all these options"
msgstr "次のサンプルは全てのこれらのオプションを含んだURLです::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:585
msgid ""
"The following example code illustrates creating and populating a memory "
"provider"
msgstr "次のサンプルコードはメモリープロバイダーを作成してデータ投入をしている様子です::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:609
msgid "Finally, let's check whether everything went well"
msgstr "最後にやったことを全て確認していきましょう::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:641
msgid "And with that reference, let us explore it a bit"
msgstr "この参照を利用して、少しだけ探索してみましょう::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:657
msgid ""
"There might be also some custom renderer types, so never make an assumption "
"there are just these types. You can query :class:`QgsRendererV2Registry` "
"singleton to find out currently available renderers::"
msgstr "カスタムレンダラーのタイプになることもあるので、上記のタイプになるとは思い込まないでください。 :class:`QgsRendererV2Registry` シングルトンを検索して現在利用可能なレンダラーを見つけることもできます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:671
msgid ""
"It is possible to obtain a dump of a renderer contents in text form --- can "
"be useful for debugging"
msgstr "レンダラーの中身をテキストフォームにダンプすることできます --- デバッグ時に役に立つでしょう::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:681
msgid "Single Symbol Renderer"
msgstr "単一シンボルレンダラ"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:687
msgid ""
"You can change the symbol used by a particular vector layer by calling "
":func:`setSymbol()` passing an instance of the appropriate symbol instance. "
"Symbols for *point*, *line* and *polygon* layers can be created by calling "
"the :func:`createSimple` function of the corresponding classes "
":class:`QgsMarkerSymbolV2`,  :class:`QgsLineSymbolV2` and "
":class:`QgsFillSymbolV2`."
msgstr "特定のベクターレイヤで使用される記号は、適切なシンボルインスタンスのインスタンスを渡しながら:func: `setSymbol()`を呼び出すことによって変更できます。*ポイント* 、*ライン*、*ポリゴン*レイヤーに対するシンボルは、対応するクラス、:class:`QgsMarkerSymbolV2`、:class:`QgsLineSymbolV2`、:class:`QgsFillSymbolV2`の:func:`createSimple`関数：を呼び出すことによって作成できます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:694
msgid ""
"The dictionary passed to :func:`createSimple` sets the style properties of "
"the symbol."
msgstr " :func:`createSimple`に渡された辞書は、シンボルのスタイルプロパティを設定します。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:697
msgid ""
"For example you can replace the symbol used by a particular **point** layer "
"by calling :func:`setSymbol()` passing an instance of a "
":class:`QgsMarkerSymbolV2` as in the following code example::"
msgstr "たとえば、次のコード例のように、:class:`QgsMarkerSymbolV2`のインスタンスを渡しつつ:func: `setSymbol()`を呼び出すことで、特定の**ポイント**レイヤーで使用されるシンボルを置換できます::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:704
msgid ""
"``name`` indicates the shape of the marker, and can be any of the following:"
msgstr "`` name``は、マーカーの形状を示しており、以下のいずれかとすることができます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:706
msgid "``circle``"
msgstr "``円形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:707
msgid "``square``"
msgstr "``方形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:708
msgid "``cross``"
msgstr "``十字``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:709
msgid "``rectangle``"
msgstr "``長方形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:710
msgid "``diamond``"
msgstr "``菱形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:711
msgid "``pentagon``"
msgstr "``五角形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:712
msgid "``triangle``"
msgstr "``三角形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:713
msgid "``equilateral_triangle``"
msgstr "``正三角形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:714
msgid "``star``"
msgstr "``星形``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:715
msgid "``regular_star``"
msgstr "``regular_star``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:716
msgid "``arrow``"
msgstr "``矢印``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:717
msgid "``filled_arrowhead``"
msgstr "``塗りつぶし矢印``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:718
msgid "``x``"
msgstr "``×印``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:721
msgid ""
"To get the full list of properties for the first symbol layer of a simbol "
"instance you can follow the example code::"
msgstr "シンボルインスタンスの最初のシンボルレイヤのプロパティの完全なリストを取得するには、サンプルコードに従うことができます::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:744
msgid "This can be useful if you want to alter some properties::"
msgstr "いくつかのプロパティを変更したい場合に便利です::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:759
msgid "Categorized Symbol Renderer"
msgstr "カテゴライズドシンボルレンダラ"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:764
msgid "To get a list of categories"
msgstr "カテゴリの配列を取得するには"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:781
msgid "Graduated Symbol Renderer"
msgstr "階調シンボルレンダラ"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:787
msgid "To find out more about ranges used in the renderer"
msgstr "レンダラで使われている領域の多くの情報を見つけるには"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:804
msgid ""
"If you wish to create your own graduated symbol renderer you can do so as "
"illustrated in the example snippet below (which creates a simple two class "
"arrangement)"
msgstr "もし連続値シンボルレンダラを作ろうとしているのであれば次のスニペットの例で書かれているようにします(これはシンプルな二つのクラスを作成するものを取り上げています)::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:848
msgid "Working with Symbols"
msgstr "シンボルの操作"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:853
msgid ":class:`QgsMarkerSymbolV2` --- for point features"
msgstr ":class:`QgsMarkerSymbolV2` - ポイントのフィーチャ用"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:854
msgid ":class:`QgsLineSymbolV2` --- for line features"
msgstr ":class:`QgsLineSymbolV2` - ラインのフィーチャ用"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:855
msgid ":class:`QgsFillSymbolV2` --- for polygon features"
msgstr ":class:`QgsFillSymbolV2` - ポリゴンのフィーチャ用"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:861
msgid ""
"Having an instance of a symbol (e.g. from a renderer), it is possible to "
"explore it: :func:`type` method says whether it is a marker, line or fill "
"symbol. There is a :func:`dump` method which returns a brief description of "
"the symbol. To get a list of symbol layers"
msgstr "(例えばレンダラから)シンボルのインスタンスを持っていればそれの中身を調べる事ができます: :func:`type` メソッドはそれ自身がマーカか、ラインか、シンボルで満たさたものかを返します。 :func:`dump` メソッドはシンボルの簡単な説明を返します。シンボルレイヤーの配列を取得するにはこのようにします::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:882
msgid "Working with Symbol Layers"
msgstr "シンボルレイヤの操作"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:891
msgid ""
"You can get a complete list of the types of symbol layers you can create for"
" a given symbol layer class like this"
msgstr "次のようにシンボルレイヤクラスを与えてシンプルレイヤを作成して、シンボルレイヤのタイプの完全なリストを取得することができます。"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:902
msgid "Output"
msgstr "出力"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:925
msgid "Creating Custom Symbol Layer Types"
msgstr "カスタムシンボルレイヤタイプの作成"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:927
msgid ""
"Imagine you would like to customize the way how the data gets rendered. You "
"can create your own symbol layer class that will draw the features exactly "
"as you wish. Here is an example of a marker that draws red circles with "
"specified radius"
msgstr "あなたがデータをどうレンダーするかをカスタマイズしたいと考えているとします。あなたはあなたが思うままにフィーチャを描画する独自のシンボルレイヤクラスを作ることができます。次の例は指定した半径で赤い円を描画するマーカを示しています::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:978
msgid ""
"Usually it is convenient to add a GUI for setting attributes of the symbol "
"layer type to allow users to customize the appearance: in case of our "
"example above we can let user set circle radius. The following code "
"implements such widget"
msgstr "普通はユーザに外観をカスタマイズさせるためにシンボルレイヤータイプの属性を設定するGUIを追加すると使いやすくなります: 上記の例であればユーザは円の半径をセットできます。次のコードはwidgetの実装となります::"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1031
msgid "We will have to create metadata for the symbol layer"
msgstr "私達はシンボルレイヤーのメタデータを作る必要があります"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1062
msgid "Creating Custom Renderers"
msgstr "カスタムレンダラの作成"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1069
msgid ""
"The following code shows a simple custom renderer that creates two marker "
"symbols and chooses randomly one of them for every feature"
msgstr "次のコードは二つのマーカーシンボルを作成して全てのフィーチャからランダムに一つ選ぶ簡単なカスタムレンダラです"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1106
msgid ""
"Like with symbol layers, it is possible to attach a GUI for configuration of"
" the renderer. It has to be derived from :class:`QgsRendererV2Widget`. The "
"following sample code creates a button that allows user to set symbol of the"
" first symbol"
msgstr "シンボルレイヤー同様、レンダラの設定をGUIからいじることができます。これは :class:`QgsRendererV2Widget` の派生クラスとなります。次のサンプルコードではユーザが最初のシンボルのシンボルをセットするボタンを作成しています(訳注: サンプルを見ると色を変更しているので原文が間違っていると思われる)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1146
msgid ""
"The last missing bit is the renderer metadata and registration in registry, "
"otherwise loading of layers with the renderer will not work and user will "
"not be able to select it from the list of renderers. Let us finish our "
"RandomRenderer example"
msgstr "最後のちょっとした作業はレンダラのメタデータとレジストリへの登録で、これらをしないとレンダラのレイヤーの読み込みは動かなく、ユーザはレンダラのリストから選択することができないでしょう。では、私達の RandomRenderer の例を終わらせましょう"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1171
msgid ""
"To associate an icon with the renderer you can assign it in "
":class:`QgsRendererV2AbstractMetadata` constructor as a third (optional) "
"argument --- the base class constructor in the RandomRendererMetadata "
":func:`__init__` function becomes"
msgstr "レンダラにアイコンを関連付けるには :class:`QgsRendererV2AbstractMetadata` のコンストラクタの三番目の引数(オプション)に指定することができます --- RandomRendererMetadata の :func:`__init__` 関数の中の基本クラスのコンストラクタはこうなります"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1189
msgid "Further Topics"
msgstr "より詳しいトピック"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1193
msgid ""
"creating/modifying symbols working with style (:class:`QgsStyleV2`) working "
"with color ramps (:class:`QgsVectorColorRampV2`) rule-based renderer (see "
"`this blogpost <http://snorf.net/blog/2014/03/04/symbology-of-vector-layers-"
"in-qgis-python-plugins>`_) exploring symbol layer and renderer registries"
msgstr "（:class:`QgsVectorColorRampV2`）色のランプでの作業（:class:` QgsStyleV2`）スタイルで作業シンボルを作成/変更ルールベースのレンダラは（ `このブログ投稿<http://snorf.net/blog/2014/03/04/symbology-of-vector-layers-in-qgis-python-plugins>`_を参照してください）探索シンボルレイヤーとレンダラ・レジストリ"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:16
msgid "attributes"
msgstr "属性"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:34
msgid "selection"
msgstr "選択"

#~ msgid ""
#~ "Iterating over the features in a vector layer is one of the most common "
#~ "tasks. Below is an example of the simple basic code to perform this task and"
#~ " showing some information about each feature. the ``layer`` variable is "
#~ "assumed to have a QgsVectorLayer object"
#~ msgstr ""

#~ msgid "Attributes can be refered by name or by index."
#~ msgstr ""

#~ msgid "This code"
#~ msgstr ""

#~ msgid "Has the same effect as this one:"
#~ msgstr ""

#~ msgid "Convenience methods"
#~ msgstr ""

#~ msgid ""
#~ "For the above cases, and in case you need to consider selection in a vector "
#~ "layer in case it exist, you can use the :func:`getfeatures` method from the "
#~ "buil-in processing plugin, as follows:"
#~ msgstr ""

#~ msgid ""
#~ "This will iterate over all the features in the layer, in case there is no "
#~ "selection, or over the selected features otherwise."
#~ msgstr ""

#~ msgid ""
#~ "The request can be used to define the data retrieved for each feature, so "
#~ "the iterator returns all features, but return partial data for each of them."
#~ msgstr ""

#~ msgid ""
#~ "Most vector data providers support editing of layer data. Sometimes they "
#~ "support just a subset of possible editing actions. Use the "
#~ ":func:`capabilities` function to find out what set of functionality is "
#~ "supported::"
#~ msgstr ""

#~ msgid ""
#~ "By using any of following methods for vector layer editing, the changes are "
#~ "directly committed to the underlying data store (a file, database etc). In "
#~ "case you would like to do only temporary changes, skip to the next section "
#~ "that explains how to do :ref:`modifications with editing buffer <editing-"
#~ "buffer>`."
#~ msgstr ""

#~ msgid ""
#~ "Create some :class:`QgsFeature` instances and pass a list of them to "
#~ "provider's :func:`addFeatures` method. It will return two values: result "
#~ "(true/false) and list of added features (their ID is set by the data "
#~ "store)::"
#~ msgstr ""

#~ msgid "To delete some features, just provide a list of their feature IDs::"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to either change feature's geometry or to change some "
#~ "attributes. The following example first changes values of attributes with "
#~ "index 0 and 1, then it changes the feature's geometry::"
#~ msgstr ""

#~ msgid ""
#~ "To add fields (attributes), you need to specify a list of field defnitions. "
#~ "For deletion of fields just provide a list of field indexes. ::"
#~ msgstr ""

#~ msgid ""
#~ "To find out whether a layer is in editing mode, use :func:`isEditing` --- "
#~ "the editing functions work only when the editing mode is turned on. Usage of"
#~ " editing functions::"
#~ msgstr ""

#~ msgid ""
#~ "In order to make undo/redo work properly, the above mentioned calls have to "
#~ "be wrapped into undo commands. (If you do not care about undo/redo and want "
#~ "to have the changes stored immediately, then you will have easier work by "
#~ ":ref:`editing with data provider <editing>`.) How to use the undo "
#~ "functionality ::"
#~ msgstr ""

#~ msgid ""
#~ "The :func:`beginEndCommand` will create an internal \"active\" command and "
#~ "will record subsequent changes in vector layer. With the call to "
#~ ":func:`endEditCommand` the command is pushed onto the undo stack and the "
#~ "user will be able to undo/redo it from GUI. In case something went wrong "
#~ "while doing the changes, the :func:`destroyEditCommand` method will remove "
#~ "the command and rollback all changes done while this command was active."
#~ msgstr ""

#~ msgid ""
#~ "To start editing mode, there is :func:`startEditing` method, to stop editing"
#~ " there are :func:`commitChanges` and :func:`rollback()` --- however normally"
#~ " you should not need these methods and leave this functionality to be "
#~ "triggered by the user."
#~ msgstr ""

#~ msgid ""
#~ "Spatial indexes can dramatically improve the performance of your code if you"
#~ " need to do frequent queries to a vector layer. Imagin, for instance, that "
#~ "you are writing an interpolation algorithm, and that for a given location "
#~ "you need to know the 10 closest point from a points layer,, in order to use "
#~ "those point for calculating the interpolated value. Without a spatial index,"
#~ " the only way for QGIS to find those 10 points is to compute the distance "
#~ "from each and every point to the specified location and then compare those "
#~ "distances. This can be a very time consuming task, specilly if it needs to "
#~ "be repeated fro several locations. If a spatial index exists for the layer, "
#~ "the operation is much more effective."
#~ msgstr ""

#~ msgid ""
#~ "Think of a layer withou a spatial index as a telephone book in which "
#~ "telephone number are not orderer or indexed. The only way to find the "
#~ "telephone number of a given person is to read from the beginning until you "
#~ "find it."
#~ msgstr ""

#~ msgid ""
#~ "Spatial indexes are not created by default for a QGIS vector layer, but you "
#~ "can create them easily. This is what you have to do."
#~ msgstr ""

#~ msgid "create spatial index --- the following code creates an empty index::"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature` object and adds it"
#~ " to the internal data structure. You can create the object manually or use "
#~ "one from previous call to provider's :func:`nextFeature()` ::"
#~ msgstr ""

#~ msgid ""
#~ "once spatial index is filled with some values, you can do some queries::"
#~ msgstr ""

#~ msgid "from an instance of :class:`QgsVectorLayer`::"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation - shapefiles are one of those --- however in case"
#~ " you are not using international characters you do not have to care much "
#~ "about the encoding. The fourth parameter that we left as ``None`` may "
#~ "specify destination CRS --- if a valid instance of "
#~ ":class:`QgsCoordinateReferenceSystem` is passed, the layer is transformed to"
#~ " that CRS."
#~ msgstr ""

#~ msgid ""
#~ "For valid driver names please consult the `supported formats by OGR`_ --- "
#~ "you should pass the value in `the \"Code\" column as the driver name. "
#~ "Optionally you can set whether to export only selected features, pass "
#~ "further driver-specific options for creation or tell the writer not to "
#~ "create attributes --- look into the documentation for full syntax."
#~ msgstr ""

#~ msgid "directly from features::"
#~ msgstr ""

#~ msgid "The following example of a URI incorporates all these options::"
#~ msgstr ""

#~ msgid ""
#~ "The following example code illustrates creating and populating a memory "
#~ "provider::"
#~ msgstr ""

#~ msgid "Finally, let's check whether everything went well::"
#~ msgstr ""

#~ msgid "And with that reference, let us explore it a bit::"
#~ msgstr ""

#~ msgid ""
#~ "There might be also some custom renderer types, so never make an assumption "
#~ "there are just these types. You can query :class:`QgsRendererV2Registry` "
#~ "singleton to find out currently available renderers."
#~ msgstr ""

#~ msgid ""
#~ "It is possible to obtain a dump of a renderer contents in text form --- can "
#~ "be useful for debugging::"
#~ msgstr ""

#~ msgid "To get a list of categories::"
#~ msgstr ""

#~ msgid "To find out more about ranges used in the renderer::"
#~ msgstr ""

#~ msgid ""
#~ "If you wish to create your own graduated symbol renderer you can do so as "
#~ "illustrated in the example snippet below (which creates a simple two class "
#~ "arrangement)::"
#~ msgstr ""

#~ msgid ":class:`QgsMarkerSymbolV2` - for point features"
#~ msgstr ""

#~ msgid ":class:`QgsLineSymbolV2` - for line features"
#~ msgstr ""

#~ msgid ":class:`QgsFillSymbolV2` - for polygon features"
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :func:`type` method says whether it is a marker, line or fill "
#~ "symbol. There is a :func:`dump` method which returns a brief description of "
#~ "the symbol. To get a list of symbol layers::"
#~ msgstr ""

#~ msgid ""
#~ "You can get a complete list of the types of symbol layers you can create for"
#~ " a given symbol layer class like this::"
#~ msgstr ""

#~ msgid "Output::"
#~ msgstr ""

#~ msgid ""
#~ "Imagine you would like to customize the way how the data gets rendered. You "
#~ "can create your own symbol layer class that will draw the features exactly "
#~ "as you wish. Here is an example of a marker that draws red circles with "
#~ "specified radius::"
#~ msgstr ""

#~ msgid ""
#~ "Usually it is convenient to add a GUI for setting attributes of the symbol "
#~ "layer type to allow users to customize the appearance: in case of our "
#~ "example above we can let user set circle radius. The following code "
#~ "implements such widget::"
#~ msgstr ""

#~ msgid "We will have to create metadata for the symbol layer::"
#~ msgstr ""

#~ msgid ""
#~ "The following code shows a simple custom renderer that creates two marker "
#~ "symbols and chooses randomly one of them for every feature::"
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererV2Widget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol::"
#~ msgstr ""

#~ msgid ""
#~ "The last missing bit is the renderer metadata and registration in registry, "
#~ "otherwise loading of layers with the renderer will not work and user will "
#~ "not be able to select it from the list of renderers. Let us finish our "
#~ "RandomRenderer example::"
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererV2AbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes::"
#~ msgstr ""

#~ msgid "creating/modifying symbols"
#~ msgstr ""

#~ msgid "working with style (:class:`QgsStyleV2`)"
#~ msgstr ""

#~ msgid "working with color ramps (:class:`QgsVectorColorRampV2`)"
#~ msgstr ""

#~ msgid "rule-based renderer"
#~ msgstr ""

#~ msgid "exploring symbol layer and renderer registries"
#~ msgstr ""
